<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pretty Screenshots</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="app-container">
    <!-- Main canvas area -->
    <div class="canvas-area">
      <div class="drop-zone" id="dropZone">
        <h2>Drop your screenshot here</h2>
        <p>or click to browse</p>
        <p>You can also paste from clipboard (<code>Ctrl+V</code> or <code>âŒ˜+V</code>)</p>
        <input type="file" id="fileInput" accept="image/*" style="display: none;">
      </div>
      <div class="canvas-wrapper hidden" id="canvasWrapper">
        <canvas id="preview-canvas"></canvas>
      </div>
    </div>

    <!-- Right sidebar with controls and export -->
    <div class="sidebar">
      <!-- Control panel -->
      <div class="control-panel">

      <!-- SIZE SECTION -->
      <div class="section-header">SIZE</div>

      <!-- Padding control -->
      <div class="control-group">
        <label class="control-label">
          <span>Padding</span>
          <span class="control-value" id="paddingValue">10.0%</span>
        </label>
        <input type="range" id="paddingSlider" min="0" max="50" value="10" step="0.5">
      </div>

      <!-- Rounded corners control -->
      <div class="control-group">
        <label class="control-label">
          <span>Rounded Corners</span>
          <span class="control-value" id="roundedValue">2.0%</span>
        </label>
        <input type="range" id="roundedSlider" min="0" max="10" value="2" step="0.1">
      </div>

      <div class="section-separator"></div>

      <!-- SHADOW SECTION -->
      <div class="section-header">SHADOW</div>

      <!-- Shadow control -->
      <div class="control-group">
        <label class="control-label">
          <span>Blur</span>
          <span class="control-value" id="shadowValue">2.5%</span>
        </label>
        <input type="range" id="shadowSlider" min="0" max="10" value="2.5" step="0.1">
      </div>

      <!-- Shadow offset X control -->
      <div class="control-group">
        <label class="control-label">
          <span>Offset X</span>
          <span class="control-value" id="shadowOffsetXValue">0.0%</span>
        </label>
        <input type="range" id="shadowOffsetXSlider" min="-5" max="5" value="0" step="0.1">
      </div>

      <!-- Shadow offset Y control -->
      <div class="control-group">
        <label class="control-label">
          <span>Offset Y</span>
          <span class="control-value" id="shadowOffsetYValue">0.6%</span>
        </label>
        <input type="range" id="shadowOffsetYSlider" min="-5" max="5" value="0.6" step="0.1">
      </div>

      <!-- Shadow opacity control -->
      <div class="control-group">
        <label class="control-label">
          <span>Opacity</span>
          <span class="control-value" id="shadowOpacityValue">50</span>
        </label>
        <input type="range" id="shadowOpacitySlider" min="0" max="100" value="50">
      </div>

      <!-- Shadow color control -->
      <div class="control-group">
        <label class="control-label">
          <span>Shadow Color</span>
        </label>
        <input type="color" id="shadowColorPicker" value="#000000">
      </div>

      <div class="section-separator"></div>

      <!-- BACKGROUND SECTION -->
      <div class="section-header">BACKGROUND</div>

      <!-- Background selection -->
      <div class="control-group">
        <label class="control-label">
          <span>Preset</span>
        </label>
        <div class="background-grid">
          <div class="background-option bg-cool active" data-bg="cool">
            <span>Cool</span>
          </div>
          <div class="background-option bg-beach" data-bg="beach">
            <span>Beach</span>
          </div>
          <div class="background-option bg-rose" data-bg="rose">
            <span>Rose</span>
          </div>
          <div class="background-option bg-love" data-bg="love">
            <span>Love</span>
          </div>
          <div class="background-option bg-flower" data-bg="flower">
            <span>Flower</span>
          </div>
          <div class="background-option bg-sky" data-bg="sky">
            <span>Sky</span>
          </div>
          <div class="background-option bg-none" data-bg="none">
            <span>None</span>
          </div>
          <div class="background-option bg-solid" data-bg="solid">
            <span>Solid Color</span>
          </div>
          <div class="background-option bg-custom" data-bg="custom">
            <span>Custom</span>
          </div>
        </div>
        <div class="custom-gradient-wrapper hidden" id="solidColorWrapper">
          <label class="control-label" style="margin-top: 0.75rem; margin-bottom: 0.5rem;">
            <span>Background Color</span>
          </label>
          <input type="color" id="solidColorPicker" value="#667eea">
        </div>
        <div class="custom-gradient-wrapper hidden" id="gradientDirectionWrapper">
          <label class="control-label" style="margin-top: 0.75rem; margin-bottom: 0.5rem;">
            <span>Gradient Direction</span>
          </label>
          <div class="gradient-direction-controls">
            <button class="gradient-direction-btn active" data-direction="diagonal">Diagonal</button>
            <button class="gradient-direction-btn" data-direction="vertical">Vertical</button>
            <button class="gradient-direction-btn" data-direction="radial">Radial</button>
          </div>
        </div>
        <div class="custom-gradient-wrapper hidden" id="customGradientWrapper">
          <label class="control-label" style="margin-top: 0.75rem; margin-bottom: 0.5rem;">
            <span>Gradient Colors</span>
            <button class="gradient-swap-btn" id="swapGradientColors" title="Swap gradient colors">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/></svg>
            </button>
          </label>
          <div class="gradient-color-pickers">
            <input type="color" id="gradientColor1" value="#667eea" title="Start color">
            <input type="color" id="gradientColor2" value="#764ba2" title="End color">
          </div>

          <label class="control-label" style="margin-top: 0.75rem; margin-bottom: 0.5rem;">
            <span>Or Use Custom Gradient</span>
            <a href="https://cssgradient.io/" target="_blank" rel="noopener noreferrer" title="Open CSS Gradient Generator">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
            </a>
          </label>
          <input type="text" id="customGradientInput" placeholder="linear-gradient(90deg, #667eea 0%, #764ba2 100%)" class="custom-gradient-input">
        </div>
      </div>

      <div class="section-separator"></div>

      <!-- CANVAS SECTION -->
      <div class="section-header">CANVAS</div>

      <!-- Ratio / Size presets -->
      <div class="control-group">
        <label class="control-label">
          <span>Aspect Ratio</span>
        </label>
        <div class="ratio-grid">
          <button class="ratio-btn active" data-ratio="auto">Auto</button>
          <button class="ratio-btn" data-ratio="4:3">4:3</button>
          <button class="ratio-btn" data-ratio="3:2">3:2</button>
          <button class="ratio-btn" data-ratio="16:9">16:9</button>
          <button class="ratio-btn" data-ratio="1:1">1:1</button>
          <button class="ratio-btn" data-ratio="9:16">9:16</button>
        </div>
      </div>

      <!-- Zoom control -->
      <div class="control-group">
        <label class="control-label">
          <span>Zoom</span>
          <span class="control-value" id="zoomValue">100%</span>
        </label>
        <input type="range" id="zoomSlider" min="50" max="200" value="100">
      </div>

      <div class="section-separator"></div>

      <!-- POSITION SECTION -->
      <div class="section-header">POSITION</div>

      <!-- Position controls -->
      <div class="control-group">
        <label class="control-label">
          <span>X Offset</span>
          <span class="control-value" id="offsetXValue">0</span>
        </label>
        <input type="range" id="offsetXSlider" min="-500" max="500" value="0">
      </div>

      <div class="control-group">
        <label class="control-label">
          <span>Y Offset</span>
          <span class="control-value" id="offsetYValue">0</span>
        </label>
        <input type="range" id="offsetYSlider" min="-500" max="500" value="0">
      </div>

      <div class="section-separator"></div>

    </div>

    <!-- Export section (sticky) -->
    <div class="export-section">
      <div class="export-grid">
        <button class="export-btn export-btn-primary" id="downloadPNG">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          PNG
        </button>
        <button class="export-btn export-btn-primary" id="downloadJPEG">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          JPG
        </button>
        <button class="export-btn export-btn-secondary" id="copyClipboard">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
          Copy to Clipboard
        </button>
      </div>
    </div>

    </div><!-- Close sidebar -->

  </div><!-- Close app-container -->

  <!-- Footer -->
  <footer class="footer">
      <p class="flex items-center justify-center gap-2">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><!-- Icon from Material Design Icons by Pictogrammers - https://github.com/Templarian/MaterialDesign/blob/master/LICENSE --><path fill="currentColor" d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"/></svg>&nbsp;
        <a
          href="https://github.com/slhck/pretty-screenshots"
          target="_blank"
          rel="noopener noreferrer"
        >
          View on GitHub
        </a>
      </p>
  </footer>

  <script>
    // Application state
    const state = {
      image: null,
      padding: 10,  // percentage of image width
      rounded: 2,   // percentage of image width
      shadow: 2.5,  // percentage of image width (blur)
      shadowOffsetX: 0,  // percentage of image width
      shadowOffsetY: 0.6,  // percentage of image width
      shadowOpacity: 50,
      shadowColor: '#000000',
      background: 'cool',
      solidColor: '#667eea',
      customGradient: 'linear-gradient(90deg, #667eea 0%, #764ba2 100%)',
      gradientDirection: 'diagonal',
      gradientColor1: '#667eea',
      gradientColor2: '#764ba2',
      useCustomGradientText: false,  // false = use color pickers, true = use text input
      ratio: 'auto',
      zoom: 100,
      offsetX: 0,
      offsetY: 0,
      isDragging: false,
      dragStartX: 0,
      dragStartY: 0
    };

    // Background gradients
    const backgrounds = {
      cool: { type: 'gradient', colors: ['#06b6d4', '#3b82f6'] },
      beach: { type: 'gradient', colors: ['#14b8a6', '#0891b2'] },
      rose: { type: 'gradient', colors: ['#f43f5e', '#ec4899'] },
      love: { type: 'gradient', colors: ['#ec4899', '#8b5cf6'] },
      flower: { type: 'gradient', colors: ['#f9a8d4', '#fbbf24'] },
      sky: { type: 'gradient', colors: ['#38bdf8', '#e0f2fe'] },
      none: { type: 'transparent', value: null },
      solid: { type: 'solid', value: null },
      custom: { type: 'custom', value: null }
    };

    // Aspect ratios
    const ratios = {
      'auto': null,
      '4:3': 4/3,
      '3:2': 3/2,
      '16:9': 16/9,
      '1:1': 1/1,
      '9:16': 9/16
    };

    // DOM elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const canvasWrapper = document.getElementById('canvasWrapper');
    const canvas = document.getElementById('preview-canvas');
    const ctx = canvas.getContext('2d');

    // Control elements
    const paddingSlider = document.getElementById('paddingSlider');
    const paddingValue = document.getElementById('paddingValue');
    const roundedSlider = document.getElementById('roundedSlider');
    const roundedValue = document.getElementById('roundedValue');
    const shadowSlider = document.getElementById('shadowSlider');
    const shadowValue = document.getElementById('shadowValue');
    const shadowOffsetXSlider = document.getElementById('shadowOffsetXSlider');
    const shadowOffsetXValue = document.getElementById('shadowOffsetXValue');
    const shadowOffsetYSlider = document.getElementById('shadowOffsetYSlider');
    const shadowOffsetYValue = document.getElementById('shadowOffsetYValue');
    const shadowOpacitySlider = document.getElementById('shadowOpacitySlider');
    const shadowOpacityValue = document.getElementById('shadowOpacityValue');
    const shadowColorPicker = document.getElementById('shadowColorPicker');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');
    const offsetXSlider = document.getElementById('offsetXSlider');
    const offsetXValue = document.getElementById('offsetXValue');
    const offsetYSlider = document.getElementById('offsetYSlider');
    const offsetYValue = document.getElementById('offsetYValue');
    const solidColorWrapper = document.getElementById('solidColorWrapper');
    const solidColorPicker = document.getElementById('solidColorPicker');
    const gradientDirectionWrapper = document.getElementById('gradientDirectionWrapper');
    const customGradientWrapper = document.getElementById('customGradientWrapper');
    const customGradientInput = document.getElementById('customGradientInput');
    const gradientColor1 = document.getElementById('gradientColor1');
    const gradientColor2 = document.getElementById('gradientColor2');
    const swapGradientColors = document.getElementById('swapGradientColors');

    // Update offset controls based on zoom
    function updateOffsetControls() {
      const isZoomed = state.zoom !== 100;
      offsetXSlider.disabled = !isZoomed;
      offsetYSlider.disabled = !isZoomed;

      // Visual feedback for both control groups
      const offsetXGroup = offsetXSlider.closest('.control-group');
      const offsetYGroup = offsetYSlider.closest('.control-group');
      if (offsetXGroup) {
        offsetXGroup.style.opacity = isZoomed ? '1' : '0.5';
      }
      if (offsetYGroup) {
        offsetYGroup.style.opacity = isZoomed ? '1' : '0.5';
      }
    }

    // Generate gradient CSS from colors and direction
    function generateGradient(color1, color2, direction) {
      if (direction === 'diagonal') {
        return `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
      } else if (direction === 'vertical') {
        return `linear-gradient(180deg, ${color1} 0%, ${color2} 100%)`;
      } else if (direction === 'radial') {
        return `radial-gradient(circle, ${color1} 0%, ${color2} 100%)`;
      }
      return `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
    }

    // Update gradient from color pickers
    function updateGradientFromColors() {
      const color1 = state.gradientColor1;
      const color2 = state.gradientColor2;
      const direction = state.gradientDirection;
      state.customGradient = generateGradient(color1, color2, direction);
    }

    // Save settings to localStorage
    function saveSettings() {
      try {
        const settings = {
          background: state.background,
          solidColor: state.solidColor,
          customGradient: state.customGradient,
          gradientDirection: state.gradientDirection,
          gradientColor1: state.gradientColor1,
          gradientColor2: state.gradientColor2,
          useCustomGradientText: state.useCustomGradientText
        };
        localStorage.setItem('prettyScreenshotsSettings', JSON.stringify(settings));
      } catch (e) {
        console.error('Failed to save settings:', e);
      }
    }

    // Load settings from localStorage
    function loadSettings() {
      try {
        const saved = localStorage.getItem('prettyScreenshotsSettings');
        if (saved) {
          const settings = JSON.parse(saved);

          // Restore state
          state.background = settings.background || state.background;
          state.solidColor = settings.solidColor || state.solidColor;
          state.customGradient = settings.customGradient || state.customGradient;
          state.gradientDirection = settings.gradientDirection || state.gradientDirection;
          state.gradientColor1 = settings.gradientColor1 || state.gradientColor1;
          state.gradientColor2 = settings.gradientColor2 || state.gradientColor2;
          state.useCustomGradientText = settings.useCustomGradientText !== undefined ? settings.useCustomGradientText : state.useCustomGradientText;

          // Update UI elements
          solidColorPicker.value = state.solidColor;
          customGradientInput.value = state.customGradient;
          gradientColor1.value = state.gradientColor1;
          gradientColor2.value = state.gradientColor2;

          // Update background selection
          document.querySelectorAll('.background-option').forEach(o => o.classList.remove('active'));
          const activeBackground = document.querySelector(`.background-option[data-bg="${state.background}"]`);
          if (activeBackground) {
            activeBackground.classList.add('active');
          }

          // Show/hide appropriate wrapper
          const bg = backgrounds[state.background];
          if (state.background === 'solid') {
            solidColorWrapper.classList.remove('hidden');
            gradientDirectionWrapper.classList.add('hidden');
            customGradientWrapper.classList.add('hidden');
          } else if (state.background === 'custom' || (bg && bg.type === 'gradient')) {
            solidColorWrapper.classList.add('hidden');
            gradientDirectionWrapper.classList.remove('hidden');
            if (state.background === 'custom') {
              customGradientWrapper.classList.remove('hidden');
            } else {
              customGradientWrapper.classList.add('hidden');
            }
          } else {
            solidColorWrapper.classList.add('hidden');
            gradientDirectionWrapper.classList.add('hidden');
            customGradientWrapper.classList.add('hidden');
          }

          // Update gradient direction button
          document.querySelectorAll('.gradient-direction-btn').forEach(b => b.classList.remove('active'));
          const activeDirection = document.querySelector(`.gradient-direction-btn[data-direction="${state.gradientDirection}"]`);
          if (activeDirection) {
            activeDirection.classList.add('active');
          }
        }
      } catch (e) {
        console.error('Failed to load settings:', e);
      }
    }

    // Initialize event listeners
    function init() {
      // Drop zone events
      dropZone.addEventListener('click', () => fileInput.click());
      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('dragleave', handleDragLeave);
      dropZone.addEventListener('drop', handleDrop);

      // File input
      fileInput.addEventListener('change', handleFileSelect);

      // Clipboard paste
      document.addEventListener('paste', handlePaste);

      // Slider controls
      paddingSlider.addEventListener('input', (e) => {
        state.padding = parseFloat(e.target.value);
        paddingValue.textContent = state.padding.toFixed(1) + '%';
        render();
      });

      roundedSlider.addEventListener('input', (e) => {
        state.rounded = parseFloat(e.target.value);
        roundedValue.textContent = state.rounded.toFixed(1) + '%';
        render();
      });

      shadowSlider.addEventListener('input', (e) => {
        state.shadow = parseFloat(e.target.value);
        shadowValue.textContent = state.shadow.toFixed(1) + '%';
        render();
      });

      shadowOffsetXSlider.addEventListener('input', (e) => {
        state.shadowOffsetX = parseFloat(e.target.value);
        shadowOffsetXValue.textContent = state.shadowOffsetX.toFixed(1) + '%';
        render();
      });

      shadowOffsetYSlider.addEventListener('input', (e) => {
        state.shadowOffsetY = parseFloat(e.target.value);
        shadowOffsetYValue.textContent = state.shadowOffsetY.toFixed(1) + '%';
        render();
      });

      shadowOpacitySlider.addEventListener('input', (e) => {
        state.shadowOpacity = parseInt(e.target.value);
        shadowOpacityValue.textContent = state.shadowOpacity;
        render();
      });

      shadowColorPicker.addEventListener('input', (e) => {
        state.shadowColor = e.target.value;
        render();
      });

      zoomSlider.addEventListener('input', (e) => {
        state.zoom = parseInt(e.target.value);
        zoomValue.textContent = state.zoom + '%';
        updateOffsetControls();
        render();
      });

      offsetXSlider.addEventListener('input', (e) => {
        state.offsetX = parseInt(e.target.value);
        offsetXValue.textContent = state.offsetX;
        render();
      });

      offsetYSlider.addEventListener('input', (e) => {
        state.offsetY = parseInt(e.target.value);
        offsetYValue.textContent = state.offsetY;
        render();
      });

      // Canvas drag to reposition
      canvas.addEventListener('mousedown', (e) => {
        if (!state.image) return;
        state.isDragging = true;
        state.dragStartX = e.clientX;
        state.dragStartY = e.clientY;
        canvas.style.cursor = 'grabbing';
      });

      document.addEventListener('mousemove', (e) => {
        if (!state.isDragging) return;
        const deltaX = e.clientX - state.dragStartX;
        const deltaY = e.clientY - state.dragStartY;

        state.offsetX += deltaX;
        state.offsetY += deltaY;

        // Update slider values
        offsetXSlider.value = state.offsetX;
        offsetXValue.textContent = state.offsetX;
        offsetYSlider.value = state.offsetY;
        offsetYValue.textContent = state.offsetY;

        state.dragStartX = e.clientX;
        state.dragStartY = e.clientY;

        render();
      });

      document.addEventListener('mouseup', () => {
        if (state.isDragging) {
          state.isDragging = false;
          canvas.style.cursor = 'grab';
        }
      });

      // Background selection
      document.querySelectorAll('.background-option').forEach(option => {
        option.addEventListener('click', function() {
          document.querySelectorAll('.background-option').forEach(o => o.classList.remove('active'));
          this.classList.add('active');
          state.background = this.dataset.bg;

          const bg = backgrounds[state.background];

          // Show/hide appropriate controls based on background type
          if (state.background === 'solid') {
            solidColorWrapper.classList.remove('hidden');
            gradientDirectionWrapper.classList.add('hidden');
            customGradientWrapper.classList.add('hidden');
          } else if (state.background === 'custom' || (bg && bg.type === 'gradient')) {
            // Show direction for all gradients (predefined and custom)
            solidColorWrapper.classList.add('hidden');
            gradientDirectionWrapper.classList.remove('hidden');
            if (state.background === 'custom') {
              customGradientWrapper.classList.remove('hidden');
            } else {
              customGradientWrapper.classList.add('hidden');
            }
          } else {
            // None/transparent
            solidColorWrapper.classList.add('hidden');
            gradientDirectionWrapper.classList.add('hidden');
            customGradientWrapper.classList.add('hidden');
          }

          saveSettings();
          render();
        });
      });

      // Solid color picker
      solidColorPicker.addEventListener('input', (e) => {
        state.solidColor = e.target.value;
        if (state.background === 'solid') {
          saveSettings();
          render();
        }
      });

      // Custom gradient input
      customGradientInput.addEventListener('input', (e) => {
        state.customGradient = e.target.value.replace(/;$/, ''); // Remove trailing semicolon if present
        state.useCustomGradientText = true;
        if (state.background === 'custom') {
          saveSettings();
          render();
        }
      });

      // Gradient direction buttons
      document.querySelectorAll('.gradient-direction-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.gradient-direction-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          state.gradientDirection = this.dataset.direction;

          const bg = backgrounds[state.background];
          if (state.background === 'custom' || (bg && bg.type === 'gradient')) {
            if (state.background === 'custom') {
              state.useCustomGradientText = false;
              updateGradientFromColors();
            }
            saveSettings();
            render();
          }
        });
      });

      // Gradient color pickers
      gradientColor1.addEventListener('input', (e) => {
        state.gradientColor1 = e.target.value;
        state.useCustomGradientText = false;
        if (state.background === 'custom') {
          updateGradientFromColors();
          saveSettings();
          render();
        }
      });

      gradientColor2.addEventListener('input', (e) => {
        state.gradientColor2 = e.target.value;
        state.useCustomGradientText = false;
        if (state.background === 'custom') {
          updateGradientFromColors();
          saveSettings();
          render();
        }
      });

      // Swap gradient colors button
      swapGradientColors.addEventListener('click', () => {
        const temp = state.gradientColor1;
        state.gradientColor1 = state.gradientColor2;
        state.gradientColor2 = temp;
        gradientColor1.value = state.gradientColor1;
        gradientColor2.value = state.gradientColor2;
        state.useCustomGradientText = false;
        if (state.background === 'custom') {
          updateGradientFromColors();
          saveSettings();
          render();
        }
      });

      // Ratio selection
      document.querySelectorAll('.ratio-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.ratio-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          state.ratio = this.dataset.ratio;
          render();
        });
      });

      // Export buttons
      document.getElementById('downloadPNG').addEventListener('click', () => downloadImage('png'));
      document.getElementById('downloadJPEG').addEventListener('click', () => downloadImage('jpeg'));
      document.getElementById('copyClipboard').addEventListener('click', copyToClipboard);

      // Load saved settings
      loadSettings();
    }

    // Drag and drop handlers
    function handleDragOver(e) {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('drag-over');
    }

    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('drag-over');

      const files = e.dataTransfer.files;
      if (files.length > 0 && files[0].type.startsWith('image/')) {
        loadImage(files[0]);
      }
    }

    // File selection handler
    function handleFileSelect(e) {
      const files = e.target.files;
      if (files.length > 0) {
        loadImage(files[0]);
      }
    }

    // Clipboard paste handler
    function handlePaste(e) {
      // Allow normal paste if focus is on an input
      const active = document.activeElement;
      if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) {
        return;
      }

      e.preventDefault();
      e.stopPropagation();

      const items = (e.clipboardData || e.originalEvent.clipboardData).items;

      for (const item of items) {
        if (item.type.indexOf('image') === 0) {
          const file = item.getAsFile();
          loadImage(file);
          break;
        }
      }
    }

    // Load image from file
    function loadImage(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          state.image = img;
          // Reset position when loading new image
          state.offsetX = 0;
          state.offsetY = 0;
          state.zoom = 100;

          // Update UI
          offsetXSlider.value = 0;
          offsetXValue.textContent = 0;
          offsetYSlider.value = 0;
          offsetYValue.textContent = 0;
          zoomSlider.value = 100;
          zoomValue.textContent = '100%';

          updateOffsetControls();
          dropZone.classList.add('hidden');
          canvasWrapper.classList.remove('hidden');
          render();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // Render canvas
    function render() {
      if (!state.image) return;

      const img = state.image;
      const zoomFactor = state.zoom / 100;

      // Calculate output dimensions based on aspect ratio
      let outputWidth = img.width;
      let outputHeight = img.height;

      // Apply aspect ratio if set
      const targetRatio = ratios[state.ratio];
      if (targetRatio) {
        const currentRatio = outputWidth / outputHeight;
        if (currentRatio > targetRatio) {
          outputWidth = outputHeight * targetRatio;
        } else {
          outputHeight = outputWidth / targetRatio;
        }
      }

      // Calculate pixel values from percentages based on image width
      const padding = Math.round(img.width * (state.padding / 100));
      const rounded = Math.round(img.width * (state.rounded / 100));
      const shadow = Math.round(img.width * (state.shadow / 100));
      const shadowOffsetX = Math.round(img.width * (state.shadowOffsetX / 100));
      const shadowOffsetY = Math.round(img.width * (state.shadowOffsetY / 100));

      // Calculate canvas size to accommodate shadow (FIXED, not affected by zoom)
      // Need to account for blur spread and offset to ensure shadow isn't clipped
      // Note: these have been fixed and multiplied by 1.0 to ensure the padding is not too strong.
      const shadowPadding = shadow > 0 ? Math.max(
        Math.ceil(shadow * 1.0 + Math.abs(shadowOffsetX)),
        Math.ceil(shadow * 1.0 + Math.abs(shadowOffsetY))
      ) : 0;
      const canvasWidth = outputWidth + (padding * 1) + (shadowPadding * 1);
      const canvasHeight = outputHeight + (padding * 1) + (shadowPadding * 1);

      // Set canvas size
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // Clear canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      // Draw background
      drawBackground(canvasWidth, canvasHeight);

      // Calculate the area of the source image to sample (affected by zoom)
      // Higher zoom = smaller source area = zoomed in
      // Lower zoom = larger source area = zoomed out
      const sourceWidth = outputWidth / zoomFactor;
      const sourceHeight = outputHeight / zoomFactor;

      // Calculate source center with offset applied
      const sourceCenterX = (img.width / 2) - state.offsetX;
      const sourceCenterY = (img.height / 2) - state.offsetY;

      // Calculate source rectangle
      let sx = sourceCenterX - (sourceWidth / 2);
      let sy = sourceCenterY - (sourceHeight / 2);

      // Clamp source rectangle to image bounds
      sx = Math.max(0, Math.min(sx, img.width - sourceWidth));
      sy = Math.max(0, Math.min(sy, img.height - sourceHeight));

      // Output position (centered in canvas with padding)
      const outputX = (canvasWidth - outputWidth) / 2;
      const outputY = (canvasHeight - outputHeight) / 2;

      // Draw shadow first
      if (shadow > 0 || shadowOffsetX !== 0 || shadowOffsetY !== 0) {
        ctx.save();

        const shadowColorRgba = hexToRgba(state.shadowColor, state.shadowOpacity / 100);
        ctx.shadowColor = shadowColorRgba;
        ctx.shadowBlur = shadow;
        ctx.shadowOffsetX = shadowOffsetX;
        ctx.shadowOffsetY = shadowOffsetY;

        ctx.fillStyle = state.shadowColor;
        roundRect(ctx, outputX, outputY, outputWidth, outputHeight, rounded);
        ctx.fill();

        ctx.restore();
      }

      // Draw image with rounded corners
      ctx.save();

      // Create rounded rectangle clipping path
      roundRect(ctx, outputX, outputY, outputWidth, outputHeight, rounded);
      ctx.clip();

      // Draw the image (sampling from source rectangle to output rectangle)
      ctx.drawImage(
        img,
        sx, sy, sourceWidth, sourceHeight,  // source rectangle (what to sample)
        outputX, outputY, outputWidth, outputHeight  // destination rectangle (where to draw)
      );

      ctx.restore();

      // Set cursor style when image is loaded
      canvas.style.cursor = state.isDragging ? 'grabbing' : 'grab';
    }

    // Draw background
    function drawBackground(width, height) {
      const bg = backgrounds[state.background];

      if (bg.type === 'transparent') {
        // Transparent checkered pattern
        const squareSize = 20;
        for (let y = 0; y < height; y += squareSize) {
          for (let x = 0; x < width; x += squareSize) {
            const isEven = ((x / squareSize) + (y / squareSize)) % 2 === 0;
            ctx.fillStyle = isEven ? '#1a1a1a' : '#2a2a2a';
            ctx.fillRect(x, y, squareSize, squareSize);
          }
        }
      } else if (bg.type === 'solid') {
        // Solid color background
        ctx.fillStyle = state.solidColor;
        ctx.fillRect(0, 0, width, height);
      } else if (bg.type === 'custom') {
        // Custom gradient from user input
        try {
          // Create a temporary div to apply the gradient
          const tempDiv = document.createElement('div');
          tempDiv.style.background = state.customGradient;
          tempDiv.style.width = width + 'px';
          tempDiv.style.height = height + 'px';
          document.body.appendChild(tempDiv);

          // Get computed style to validate
          const computedStyle = window.getComputedStyle(tempDiv);
          const bgImage = computedStyle.backgroundImage;

          document.body.removeChild(tempDiv);

          // If valid, parse and draw the gradient
          if (bgImage && bgImage !== 'none') {
            // Check for radial gradient
            const radialMatch = state.customGradient.match(/radial-gradient\(([^)]+)\)/);
            if (radialMatch) {
              const params = radialMatch[1];
              const colorStopsMatch = params.match(/,(.+)$/);
              if (colorStopsMatch) {
                const colorStops = colorStopsMatch[1].split(/,(?![^(]*\))/).map(s => s.trim());

                // Create radial gradient centered
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.max(width, height) / 2;
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);

                // Add color stops
                colorStops.forEach(stop => {
                  const match = stop.match(/(.+?)\s+(\d+%)/);
                  if (match) {
                    const color = match[1].trim();
                    const position = parseFloat(match[2]) / 100;
                    gradient.addColorStop(position, color);
                  }
                });

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
              }
            } else {
              // Linear gradient
              const gradientMatch = state.customGradient.match(/linear-gradient\(([^,]+),(.+)\)/);

              if (gradientMatch) {
                const angle = gradientMatch[1].trim();
                const colorStops = gradientMatch[2].split(/,(?![^(]*\))/).map(s => s.trim());

                // Parse angle
                let x0 = 0, y0 = 0, x1 = 0, y1 = height;
                if (angle.includes('deg')) {
                  const degrees = parseFloat(angle);

                  if (degrees === 90) {
                    x0 = 0; y0 = 0; x1 = width; y1 = 0;
                  } else if (degrees === 135) {
                    x0 = 0; y0 = 0; x1 = width; y1 = height;
                  } else if (degrees === 180) {
                    x0 = 0; y0 = 0; x1 = 0; y1 = height;
                  } else {
                    const radians = (degrees - 90) * Math.PI / 180;
                    x1 = width * Math.cos(radians);
                    y1 = height * Math.sin(radians);
                  }
                }

                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);

                // Add color stops
                colorStops.forEach(stop => {
                  const match = stop.match(/(.+?)\s+(\d+%)/);
                  if (match) {
                    const color = match[1].trim();
                    const position = parseFloat(match[2]) / 100;
                    gradient.addColorStop(position, color);
                  }
                });

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
              }
            }
          } else {
            // Fallback to default if invalid
            drawDefaultGradient(width, height);
          }
        } catch (e) {
          console.error('Invalid gradient:', e);
          drawDefaultGradient(width, height);
        }
      } else if (bg.type === 'gradient') {
        // Generate gradient from colors with current direction
        const color1 = bg.colors[0];
        const color2 = bg.colors[1];
        const direction = state.gradientDirection;

        if (direction === 'radial') {
          // Radial gradient
          const centerX = width / 2;
          const centerY = height / 2;
          const radius = Math.max(width, height) / 2;
          const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
          gradient.addColorStop(0, color1);
          gradient.addColorStop(1, color2);
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);
        } else {
          // Linear gradient
          let x0 = 0, y0 = 0, x1 = 0, y1 = height;

          if (direction === 'diagonal') {
            x0 = 0; y0 = 0; x1 = width; y1 = height;
          } else if (direction === 'vertical') {
            x0 = 0; y0 = 0; x1 = 0; y1 = height;
          }

          const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
          gradient.addColorStop(0, color1);
          gradient.addColorStop(1, color2);
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);
        }
      }
    }

    // Fallback gradient for invalid custom gradients
    function drawDefaultGradient(width, height) {
      const gradient = ctx.createLinearGradient(0, 0, width, height);
      gradient.addColorStop(0, '#667eea');
      gradient.addColorStop(1, '#764ba2');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }

    // Helper function for rounded rectangles
    function roundRect(ctx, x, y, width, height, radius) {
      if (radius === 0) {
        ctx.rect(x, y, width, height);
        return;
      }

      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
      // Remove # if present
      hex = hex.replace('#', '');

      // Parse hex values
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);

      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Download image
    function downloadImage(format) {
      if (!state.image) return;

      const link = document.createElement('a');
      link.download = `screenshot-${Date.now()}.${format}`;

      if (format === 'png') {
        link.href = canvas.toDataURL('image/png');
      } else if (format === 'jpeg') {
        link.href = canvas.toDataURL('image/jpeg', 0.95);
      }

      link.click();
    }

    // Copy to clipboard
    async function copyToClipboard() {
      if (!state.image) return;

      try {
        canvas.toBlob(async (blob) => {
          await navigator.clipboard.write([
            new ClipboardItem({ 'image/png': blob })
          ]);

          // Visual feedback
          const btn = document.getElementById('copyClipboard');
          const originalHTML = btn.innerHTML;
          btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>Copied!';
          setTimeout(() => {
            btn.innerHTML = originalHTML;
          }, 2000);
        });
      } catch (err) {
        console.error('Failed to copy to clipboard:', err);
        alert('Failed to copy to clipboard. Your browser may not support this feature.');
      }
    }

    // Initialize the app
    init();
  </script>
</body>
</html>
